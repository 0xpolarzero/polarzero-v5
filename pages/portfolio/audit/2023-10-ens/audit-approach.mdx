import AuditReportLayout from '@/components/layouts/audit-report';

## 2. Audit approach

Time spent: ~40 hours

### 2.1 First overview

When I started the review, the first thing I did was to get a broader understanding of the system it is supposed to be part of, namely, the Ethereum Name Service. That’s why I started with a first look at the documentation, and mostly some back and forth with an AI, provided with the description of the contest, the code of the file in scope and some additional context. This gave me an abstract understanding of this specific system, how it could be used, as well as its benefits compared to existing similar structures. After a while, I was ready to go deeper into the code.

### 2.2 Environment

The first practical step was to convert the Hardhat tests into a Foundry environment. This would be a good starting point for the following parts, and eventually a good way to understand the system better. That’s when I truly grasped how “simple” it was: a single function that can be called by users, which will crawl through the provided arrays, each time performing one of three possible actions.

### 2.3 Testing

The tests already had 100% coverage, accounting for all the expected cases. My aim was to try to cover edge cases; flood it with large amounts of random arrays, in a progressively more accurate approach. The threat could come from both angles: meticulously crafted input data that would abuse the system, and unexpected or excessively large amounts of data that would break it.

It started with stateless fuzzing, throwing random data to the function. Then gradually less random as I would have it grab random credible inputs, and gradually more organized to perform one of three possible operations: delegate tokens from the user to a delegate, from a delegate to another, and withdraw them from a delegate. Which is the point where I switched to _stateful_ fuzzing, and defined invariants.

### 2.4 Threats & invariants

My primary concern in this system was that someone would be able to **steal tokens** from someone else - especially from a proxy contract, or end up with their funds **stuck** in a proxy.

A less concerning, but still significant issue, would be if someone were able to **inflate votes** without actually spending tokens, thus rendering the whole system obsolete.

The invariants mentioned in the details of the contest were the following:
**a.** Tokens should only be transferred between approved delegators.
**b.** The owner should only have the ability to change the URI for ERC1155 metadata.

I supplemented them with the following assumptions:
**c.** The amounts of `ERC20` tokens delegated to an individual should always strictly equal the amount of `ERC1155` tokens owned for the ID corresponding to their address.
**d.** The balance of a proxy contract should always strictly equal the votes of its associated delegate.
**e.** A proxy contract should always contain as many tokens as the cumulative amount its delegate has been trusted with by multiple delegators.

The latter might seem a bit redundant, but it’s never too much.

### 2.5 Reports

The extensive testing and examination of the contract did not reveal - at least to me - any significant bug. Actually, any unexpected behavior at all. At some point, I felt I had exhausted a fair amount of options; I decided to focus on this write-up, and on reporting optimizations and informational “issues”.

export default (props) => (
  <AuditReportLayout selected="audit-approach" slug="2023-10-ens" {...props} />
);
