import AuditReportLayout from '@/components/layouts/audit-report';

## 3. Mechanism review

The `ERC20MultiDelegate` contract deploys/retrieves an individual `ERC20ProxyDelegator` proxy contract for each delegate, which hold the tokens they were delegated by various users.

The actual voting power/weight of each delegate is tracked with the `ERC20Votes` functionalities, saving a series of checkpoints to allow for retrieving their weight at the current time, as well as at a specific date. The amount of tokens distributed across delegates for a user is efficiently tracked by an `ERC1155` token, which associates each delegate’s address (as an ID) to the various balances of their delegators. These balances are “attached” to the amount of the actual token stored in the delegate’s proxy; not as it would **\*\*\***belong**\*\*\*** to them, but as it is a unique contract _associated_ to their address, providing a trust-minimized way to actually store the delegated tokens.

The only operating function accessible to the users is called `delegateMulti` and takes multiple parameters, to perform the various previously mentioned operations. The contract ensures that tokens are transferred correctly and that the `ERC1155` balances reflect these changes.

The following is a simplified call graph of the `ERC20MultiDelegate` contract, highlighting the different steps of the process, especially the three possible outcomes when calling `delegateMulti`. You can refer back to it throughout the analysis.

![Graph.jpg](https://user-images.githubusercontent.com/99199454/274353269-b2d8d80d-8b7a-45a9-9ffe-4b5fbfa79378.jpg)

The following is a **list of key points related to this function**, in the overall context of the contract, and should provide a better understanding of the possibilities. It is followed by a **higher level example of interactions** that can be expected, in an attempt to provide a comprehensive technical and conceptual perception of the system.

### 3.1 Key aspects

**3.1.1 `ERC20MultiDelegate` contract**
**a.** The main function `delegateMulti` allows a user to specify source delegates (from whom tokens are withdrawn), target delegates (to whom tokens are given), and the amounts to be transferred.
**b.** After making sure the highest number of sources or targets is equal to the number of amounts, it goes through each index, opening the following three possible outcomes:

- The index includes **both a source and a target.**
  - Tokens are transferred **from the source's proxy** contract **to the target's proxy** contract.
- The index includes **only a target**
  - Tokens are transferred **from the user** (calling the function) **to the unique proxy** contract associated to the delegate’s address.
- The index includes **only a source**.
  - Tokens are transferred **from the proxy** contract associated to the source, **back to the user** calling the function, thus canceling the delegation and withdrawing the tokens.

**c.** Each of the above described outcomes **will not allow** any of such transfers if the caller is not the actual delegator to the sources passed to the function, or is passing an inflated amount.
**d.** It won’t transfer either if the allowance for the token is insufficient; actually, **it seems to revert** if any of the intended transfers/delegations is **inaccurate**, **abusive**, or simply **not possible**.
**e.** Each **delegate** address can be treated as a **unique token ID** due to the `ERC1155` implementation.
**f.** Proxy contracts for delegates are **created on-demand**. If a delegate doesn't have a proxy contract yet, one is deployed when required. This is done in the `deployProxyDelegatorIfNeeded` function.
**g.** The address of a proxy contract for a specific delegate is **deterministically computed** using the `retrieveProxyContractAddress` function. This ensures that for a given delegate, the proxy contract's address will **always** be the same.

**3.1.2 `ERC20ProxyDelegator` contract**
**h.** Every time this contract is deployed, it approves the `ERC20MultiDelegate` contract to spend all of its ERC20 tokens, so it can transfer them on its behalf.
**i.** Immediately after the approval, the proxy contract delegates its votes to a specified delegate; more precisely, the one whose address was used to compute its own. This means the voting power of the tokens **held by the proxy** will be **assigned to the delegate**.

**3.1.3 Tracking the amount of `ERC1155`**
**j.** Since the ERC1155 contract can manage multiple tokens, each representing a delegate, the balance of a specific delegate/token for an account can be checked using the `balanceOf` function.
**k.** In the context of this system, this `balanceOf` function will return **the exact same amount as `ERC20` tokens delegated** by this account to this specific delegate (ID).
**l.** This is due to the fact that when delegating tokens, the `ERC1155` balances are updated accordingly, making it a record of how much `ERC20` tokens an account has delegated to each delegate.

### 3.2 Step-by-step interactions

**3.2.1 Setting up**
**a.** Alice has a certain amount of `ERC20` tokens in her wallet (inheriting from `ERC20Votes`).
**b.** She identifies multiple proposals or candidates she wishes to support in the upcoming ENS governance vote. She decides she wants to delegate her tokens among them.

**3.2.2 Initial delegation**
**c.** Alice decides to delegate her tokens among three delegates: Bob, Charlie, and Dave.
**d.** She wants to split her tokens equally among them.
**e.** Alice calls the `delegateMulti` function, providing three target addresses - `Bob`, `Charlie`, `Dave` - and the amount for each.

- Internally, the contract:
  - _Checks if proxy contracts already exist for `Bob`, `Charlie`, and `Dave`._
  - _Deploys proxy contracts for any delegate that doesn't have one._
  - _Transfers Alice's tokens to these proxy contracts and updates her `ERC1155` balance for each, by minting her the appropriate amount of tokens._
  - _The proxy contracts then delegate the votes to `Bob`, `Charlie`, and `Dave` respectively._

**3.2.3 Changing delegation**
**g.** After some time, Alice decides she wants to change her delegation. She wants to remove her delegation from Dave and split their share between Bob and Charlie.
**h.** Alice calls the `delegateMulti` function again. This time, she provides `Dave`'s address as a `source` (indicating she's withdrawing from him) and `Bob` and `Charlie` addresses as `targets`.

- Internally, the contract:
  - _Withdraws the tokens from Dave's proxy contract._
  - _Splits and redistributes these tokens to Bob's and Charlie’s proxy contracts._
  - _Updates her `ERC1155` balances for all of them, by burning/minting the associated tokens in batches._
  - _The proxies then adjust the delegation accordingly._

**3.2.4 Reclaiming tokens**
**i.** At some point, Alice decides she wants to reclaim some of her tokens from Bob and Charlie.
**j.** She calls the `delegateMulti` function, providing `Bob` and `Charlie`’s addresses as `sources` but doesn't provide any targets.

- Internally, the contract:
  - _Withdraws the tokens from the proxy contracts of both Bob and Charlie._
  - _Transfers them directly to Alice’s wallet._
  - _Burns all of her ERC1155 tokens for the IDs corresponding to Bob and Charlie’s addresses._
  - _The proxy then resets her delegation for both delegates._

export default (props) => (
  <AuditReportLayout selected="mechanism-review" slug="2023-10-ens" {...props} />
);
